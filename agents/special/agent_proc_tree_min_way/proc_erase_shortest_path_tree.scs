scp_program -> proc_erase_shortest_path_tree
(* 
	-> rrel_params: 
	... 
	(*
		-> rrel_1: rrel_in: _shortest_path_tree;;
	*);;

	-> rrel_operators: 
	... 
		(*
			//1. Проверка на корректность. Проверяем является ли поданный узел деревом
			-> rrel_init: ..proc_erase_shortest_path_tree_operator1
			(*
				<- searchElStr3;;
				-> rrel_1: rrel_fixed: rrel_scp_const: concept_tree;;
				-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc1;;
				-> rrel_3: rrel_fixed: rrel_scp_var: _shortest_path_tree;;

				=> nrel_then: ..proc_erase_shortest_path_tree_operator2;;
				=> nrel_else: ..proc_find_shortest_path_tree_error1;;
			*);;
			
			//2. Поиск корня дерева
			-> ..proc_erase_shortest_path_tree_operator2
			(*
				<- searchElStr5;;
				-> rrel_1: rrel_fixed: rrel_scp_const: _shortest_path_tree;;
				-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc2;;
				-> rrel_3: rrel_assign: rrel_scp_var: _root;;
				-> rrel_4: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc3;;
				-> rrel_5: rrel_fixed: rrel_scp_const: rrel_tree_root;;
				
				=> nrel_then: ..proc_erase_shortest_path_tree_operator3;;
				=> nrel_else: ..proc_find_shortest_path_tree_error2;;
			*);;
			
			//3. Проверка на корректность. Принадлежит ли начальная вершина к множеству вершин графа
			-> ..proc_erase_shortest_path_tree_operator3
			(*
				<- searchElStr5;;
				-> rrel_1: rrel_fixed: rrel_scp_const: _shortest_path_tree;;
				-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc2_1;;
				-> rrel_3: rrel_fixed: rrel_scp_var: _root;;
				-> rrel_4: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc4;;
				-> rrel_5: rrel_fixed: rrel_scp_const: rrel_vertex;;
				
				=> nrel_then: ..proc_erase_shortest_path_tree_operator5;;
				=> nrel_else: ..proc_find_shortest_path_tree_error3;;
			*);;
			
			//3.
			-> ..proc_erase_shortest_path_tree_operator5
			(*
				<- searchElStr5;;
				-> rrel_1: rrel_fixed: rrel_scp_const: _shortest_path_tree;;
				-> rrel_2: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc9;;
				-> rrel_3: rrel_assign: rrel_scp_var: rrel_common: _commom_arc;;
				-> rrel_4: rrel_assign: rrel_scp_var: rrel_pos_const_perm: _arc8;;
				-> rrel_5: rrel_fixed: rrel_scp_const: rrel_oredge;;
				
				=> nrel_then: ..proc_erase_shortest_path_tree_operator6;;
				=> nrel_else: ..proc_erase_shortest_path_tree_operator_return;;
			*);;
			
			-> ..proc_erase_shortest_path_tree_operator6
			(*
				<- eraseEl;;
				-> rrel_1: rrel_fixed: rrel_scp_var: rrel_erase: rrel_commom: _commom_arc;;
			
				=> nrel_goto: ..proc_erase_shortest_path_tree_operator5;;
			*);;

			-> ..proc_find_shortest_path_tree_error1
			(*
				<- printNl;;
				-> rrel_1: rrel_fixed: rrel_scp_const: [Неправильные входные данные. Это не дерево.];;
				
				=> nrel_goto: ..proc_erase_shortest_path_tree_operator_return;;
			*);;
			
			-> ..proc_find_shortest_path_tree_error2
			(*
				<- printNl;;
				-> rrel_1: rrel_fixed: rrel_scp_const: [Не найден корень дерева];;
				
				=> nrel_goto: ..proc_erase_shortest_path_tree_operator_return;;
			*);;
			
			-> ..proc_find_shortest_path_tree_error3
			(*
				<- printNl;;
				-> rrel_1: rrel_fixed: rrel_scp_const: [Не корректные данные. Начальная вершина не принадлежит множеству вершин];;
				
				=> nrel_goto: ..proc_erase_shortest_path_tree_operator_return;;
			*);;
			
			-> ..proc_erase_shortest_path_tree_operator_return
			(*
				<- return;;
			*);;
	*);;
*);;
