proc_find_condensation
=> nrel_initiation_condition_and_result: (..scp_program_proc_find_condensation_initiation_condition
					  => ..scp_program_proc_find_condensation_result);

-> rrel_key_sc_element: concept_graph; nrel_condensation_of_the_digraph;
-> rrel_solver_key_sc_element: nrel_condensation_of_the_digraph;

<- rrel_key_sc_element:
	..scp_program_proc_find_condensation_behavior
	(*
		<- sc_description_of_scp_program_behavior;;
		<= nrel_sc_text_translation:
		...
		(*
			-> rrel_example:
				[Это программа создает граф конденсации и связывает его с иходным графом отношением "конденсация орграфа*"];;
		*);;
	*);;

..scp_program_proc_find_condensation_initiation_condition
= [*
	concept_graph _-> _curr_graph;;
*];;


..scp_program_proc_find_condensation_result
= [*
	concept_graph _-> _curr_graph;;
	_curr_graph _=> nrel_condensation_of_the_digraph: _result_graph;;
*];;

proc_find_condensation
    => nrel_main_idtf: [Calculate graph condensation](* <- lang_en;; *);
    => nrel_main_idtf: [Вычислить граф конденсации](* <- lang_ru;; *);
    
    => definition: ...(*
		-> rrel_key_sc_element: proc_find_condensation;;
		
		=> nrel_main_idtf: [Опр. процедура нахождения графа конденсации] (* <- lang_ru;; *);;
        => nrel_main_idtf: [Def. procedure of finding condensation of a graph] (* <- lang_en;; *);;
        
		<= nrel_using_constants: ...(*
			-> concept_graph;;
			-> nrel_condensation_of_the_digraph;;
		*);;

		<= nrel_sc_text_translation: ...(*
			-> [Данная процедура находит граф конденсации для переданног в нее графа] (*<- lang_ru;;*);;
			-> [This procedure finds graph of condensation for passed graph] (*<- lang_en;;*);;
		*);;
	*);
	
	=> affirmation: ...(*
		-> rrel_key_sc_element: proc_find_condensation;;
		
		=> nrel_main_idtf: [Документация по процедура нахождения графа конденсации] (* <- lang_ru;; *);;
        => nrel_main_idtf: [Docs about the procedure of finding condensation of a graph] (* <- lang_en;; *);;
        
		<= nrel_using_constants: ...(*
			-> concept_graph;;
			-> nrel_condensation_of_the_digraph;;
			-> proc_find_condensation_dfs1;;
			-> proc_find_condensation_dfs2;;
			-> proc_find_condensation_dfs3;;
			-> proc_find_condensation_add_to_queue;;
		*);;

		<= nrel_sc_text_translation: ...(*
			-> [  <h4>Параметры</h4>Данная процедура принимает на вход один аргумент: граф, конденсацию которого необходимо найти. Данный граф должен быть
			      записан в следующем формате: граф должен содержать два множества - множество дуг (под отношением `rrel_arcs`)
			      и множество вершин (под отношением `rrel_nodes`)<br/>
			     
			      <h4>Используемый алгоритм:</h4>Используется алгоритм предложенный Косараю и Шариром в 1979 году. Ассимптотика O(n).
			      Алгоритм использует три серии DFS. Суть алгоритма такова: мы запускаем DFS из каждой вершины (при этом не запускаем
			      его из уже посещенных вершин). После выхода DFS из какой-либо вершины данная вершина добавляется в начало очереди. После этого
			      мы начинаем доставать из очереди вершины (начиная с начала). Из этих вершин запускаем второй DFS, который ходит по 
			      графу так, как если бы он был транспонирован. Все вершины достигнетые из текущей добавляются в очередную КСС
			      (компоненту сильной связности). Затем, мы берем по одной любой вершине из каждой КСС и запускаем трейтий DFS из нее.
			      Если в процессе его исполнения был совершен переход из вершины принадлежащей одной КСС в вершину принадлежащую другой, то
			      между соответствующими вершинами в графе конденсации строится дуга.
			      <br>
			 
			      <h4>Описание работы программы:</h4>Выполнение начинается с того, что у графа проверяется наличие множеств вершин и ребер.
			     Если одно из них не было найдено - выводится ошибка и программа завершается. Инициализируется множество непусты
			      <h4>Этап 1. Построение очереди</h4>
			     В начале, создается несколько константных узлов:
                <ul>
                                   <li> Создается узел, который будет ссылаться на начало очереди. </li>
                    <li> Создаются следующие отношения: отношение указывающее на следующий элемент очереди <i>rrel_next</i> и отношение указывающее на значение элемента очереди <i>rrel_value</i></li>
                    <li> Узел, который является множеством посещенных вершины (очевидно, изначально пустой)</li>
                </ul>

                <p>Затем вызывается <i>proc_find_condensation_dfs1</i>, которая представляет собой первый DFS. Данная процедура вызывает <i>proc_find_condensation_add_to_queue</i>, которая строит очередь из вершин в порядке убывания времени выхода.
                </p>
                <p>Работу первого DFS можно описать следующим образом: она рекурсивно вызывает себя из всех смежных вершин, относительно текущей вершины. Затем она добавляет текущую вершину в очередь.
                </p>
                <p>Стоит заметить, что очередная вершина, всегда добавляется именно в начало очереди. Это сделано для того, чтобы в последствии, было удобно обходить очередь, так как по алгоритму необходимо выбирать вершины в порядке убывания времени выхода. Поэтому, очередь имеет тип LIFO, как стек. Однако, так как не имеется функций, которые могут удалять элементы из очереди, невозможно говорить, о принадлежности данной структуры данных к какой-либо из общепринятых.
                </p>
                <p> После того, как очередь для последующего обхода была построена, начинается вторая стадия алгоритма.
                <h4>Этап 2. Нахождение КСС</h4>
                Сначала происходит инициализация. Строятся следующие узлы:
                <ul>
                    <li> Узел, который будет содержать все вершины, которые уже присвоены какой-то КСС <i>condensation</i></li>
                    <li> Узел, который будет содержать все КСС</li>
                </ul>

                <ol>
                    <li> Берется очередная вершина из очереди (начиная сначала очереди). Назовем ее <i>vertex</i></li>
                    <li> Создается новый узел, который будет содержать все ребра идущие от <i>condensation</i> до вершины текущей КСС. Назовем его <i>scc</i></li>
                    <li> Запускается поиск в глубину (<i>proc_find_condensation_dfs2</i>) из <i>vertex</i>. Главная особенность данного DFS, в том, что он обходит оригинальный граф, так как будто бы он был транспонирован. Также, данный DFS добавляет все вершины, по которым проходит в <i>condensation</i>. При этом дуги, идущие от <i>condensation</i> к вершинам добавляются в <i>scc</i></li>

                    <li> Создается новый узел, который будет представлять текущую КСС в результирующем графе конденсации</li>
                    <li> Он добавляется в результирующий граф и связывается с <i>scc</i> через отношение <i>rrel_representation</i></li>
                </ol>
                </p>
                <p>Теперь когда каждая вершина графа принадлежит какой-либо КСС и когда для каждой КСС имеется вершина в графе конденсации, начинается третья стадия алгоритма - связывание соответствующих вершин в графе конденсации. 
                <h4>Этап 3. Связывание КСС в графе конденсации</h4>
                </p>
                <p>Данная стадия происходит следующим образом: для каждой КСС выбирается одна (случайная) вершина и из нее запускается поиск в глубину (<i>proc_find_condensation_dfs3</i>). В него передается текущая КСС <i>current_scc</i>. Логику его работы имеет смысл рассмотреть подробнее:
                <ol>
                    <li> В первую очередь, для текущей вершины находится КСС которой она принадлежит. Данная КСС сравнивается с <i>current_scc</i></li>
                    <li> Если они равны, то DFS распространяется на все смежные вершины</li>
                    <li> Если они не равны, то с помощью отношения <i>rrel_representation</i>, находятся вершины, представляющие данные КСС в графе конденсации, и, если они еще не были связаны, связываются дугой общего вида, которая добавляется во множество дуг результирующего графа.</li>
                </ol>
                </p>
                <p>Псоле этого, построение графа конденсации завершается. Остается лишь один этап, имеющий исключительно техническое значение - очистка памяти.
                <h4>Этап 4. Очистка памяти</h4>
                Очистку памяти можно разбить на три части:
                <ol>
                    <li> Удаление отдельно взятых узлов - таких как, например, множество обработанных вершин.</li>
                    <li> Удаление всех КСС</li>
                    <li> Очистка очереди </li>
                </ol>
			     
			     ] (*<- lang_ru;; => nrel_format: format_html;;*);;
			-> [This procedure finds graph of condensation for passed graph] (*<- lang_en;; => nrel_format: format_html;;*);;
		*);;
	*);;
